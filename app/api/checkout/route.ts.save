// /app/api/stripe/webhook/route.ts
import { NextRequest, NextResponse } from "next/server";
import { supabase } from "@/lib/db";
import Stripe from "stripe";

export const runtime = "nodejs";

const stripe = process.env.STRIPE_SECRET_KEY
  ? new Stripe(process.env.STRIPE_SECRET_KEY, {
      apiVersion: "2024-10-28.acacia",
    })
  : null;

const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET;

export async function POST(req: NextRequest) {
  if (!stripe || !endpointSecret) {
    console.error("Stripe oder Webhook-Secret fehlt");
    return NextResponse.json({ error: "Stripe nicht konfiguriert" }, { status: 400 });
  }

  try {
    const body = await req.text();
    const signature = req.headers.get("stripe-signature");

    if (!signature) {
      console.error("Keine Stripe-Signatur gefunden");
      return NextResponse.json({ error: "Keine Signatur" }, { status: 400 });
    }

    // Event verifizieren
    let event: Stripe.Event;
    try {
      event = stripe.webhooks.constructEvent(body, signature, endpointSecret);
    } catch (err: any) {
      console.error("Webhook-Signatur-Verifikation fehlgeschlagen:", err.message);
      return NextResponse.json({ error: "Invalid signature" }, { status: 400 });
    }

    console.log("Stripe Webhook Event:", event.type);

    // Event-Handler
    switch (event.type) {
      case "checkout.session.completed":
        await handleCheckoutSessionCompleted(event.data.object as Stripe.Checkout.Session);
        break;

      case "payment_intent.succeeded":
        await handlePaymentIntentSucceeded(event.data.object as Stripe.PaymentIntent);
        break;

      case "payment_intent.payment_failed":
        await handlePaymentIntentFailed(event.data.object as Stripe.PaymentIntent);
        break;

      default:
        console.log(`Unbehandelter Event-Typ: ${event.type}`);
    }

    return NextResponse.json({ received: true });
  } catch (err: any) {
    console.error("Webhook-Fehler:", err);
    return NextResponse.json({ error: "Webhook-Verarbeitung fehlgeschlagen" }, { status: 500 });
  }
}

// Event-Handler Funktionen
async function handleCheckoutSessionCompleted(session: Stripe.Checkout.Session) {
  console.log("Checkout Session abgeschlossen:", session.id);

  const orderId = session.client_reference_id || session.metadata?.order_id;
  const customerEmail = session.customer_email || session.customer_details?.email;

  if (!orderId) {
    console.error("Keine Order-ID in Session gefunden");
    return;
  }

  try {
    const { error } = await supabase
      .from("orders")
      .update({
        status: "paid",
        stripe_payment_intent_id: session.payment_intent as string,
        updated_at: new Date().toISOString(),
      })
      .eq("id", orderId);

    if (error) {
      console.error("Fehler beim Aktualisieren der Order:", error);
    } else {
      console.log(`Order ${orderId} erfolgreich als bezahlt markiert`);
    }
  } catch (err) {
    console.error("Supabase-Fehler:", err);
  }
}

async function handlePaymentIntentSucceeded(paymentIntent: Stripe.PaymentIntent) {
  console.log("Payment Intent erfolgreich:", paymentIntent.id);

  const orderId = paymentIntent.metadata?.order_id;
  if (!orderId) {
    console.error("Keine Order-ID in PaymentIntent-Metadaten gefunden");
    return;
  }

  try {
    // Zus채tzliche Informationen aus PaymentIntent extrahieren
    let email: string | null = null;
    let name: string | null = null;

    // Versuche Email aus verschiedenen Quellen zu extrahieren
    if (paymentIntent.receipt_email) {
      email = paymentIntent.receipt_email;
    }

    // F체r weitere Details m체ssen wir die Charges separat abrufen
    if (stripe) {
      try {
        const charges = await stripe.charges.list({
          payment_intent: paymentIntent.id,
          limit: 1,
        });

        if (charges.data.length > 0) {
          const charge = charges.data[0];
          if (charge.billing_details) {
            email = email || charge.billing_details.email;
            name = charge.billing_details.name;
          }
        }
      } catch (chargeErr) {
        console.log("Konnte Charge-Details nicht abrufen:", chargeErr);
      }
    }

    const updateData: any = {
      status: "paid",
      stripe_payment_intent_id: paymentIntent.id,
      updated_at: new Date().toISOString(),
    };

    if (email) updateData.email = email;
    if (name) updateData.name = name;

    const { error } = await supabase
      .from("orders")
      .update(updateData)
      .eq("id", orderId);

    if (error) {
      console.error("Fehler beim Aktualisieren der Order:", error);
    } else {
      console.log(`Order ${orderId} erfolgreich 체ber PaymentIntent aktualisiert`);
    }
  } catch (err) {
    console.error("Fehler bei PaymentIntent-Verarbeitung:", err);
  }
}

async function handlePaymentIntentFailed(paymentIntent: Stripe.PaymentIntent) {
  console.log("Payment Intent fehlgeschlagen:", paymentIntent.id);

  const orderId = paymentIntent.metadata?.order_id;
  if (!orderId) {
    console.error("Keine Order-ID in PaymentIntent-Metadaten gefunden");
    return;
  }

  try {
    const { error } = await supabase
      .from("orders")
      .update({
        status: "failed",
        stripe_payment_intent_id: paymentIntent.id,
        updated_at: new Date().toISOString(),
      })
      .eq("id", orderId);

    if (error) {
      console.error("Fehler beim Aktualisieren der fehlgeschlagenen Order:", error);
    } else {
      console.log(`Order ${orderId} als fehlgeschlagen markiert`);
    }
  } catch (err) {
    console.error("Fehler bei fehlgeschlagener PaymentIntent-Verarbeitung:", err);
  }
}